#include <iostream>
#include "fstream" 
#include <Windows.h>
#include <openssl/rsa.h>
#include <openssl/rc4.h>
#include "openssl/pem.h"
#include "openssl/err.h"
#include "string.h"
extern "C" {
#include "openssl/applink.c"
};
using namespace std;
#pragma comment(lib,"libssl.lib")
#pragma comment(lib,"libcrypto.lib")


#define OPENSSLKEY "private.key"
#define RELESE(P) if (P){delete P;P = NULL;}
#define RELESE_ARRAY(P) if (P){delete[] P;P = NULL;}
char *szFilepath = NULL;


long lSize;
char* buffer;
size_t result;




//RSA解密CR4密钥
char* decrypt_cr4_key(char* str, const char* prikey_path)
{
	char* pDedata;
	RSA* pRsa;
	FILE* pPrikey;
	int nRsalen;


	if ((pPrikey = fopen(szFilepath, "r")) == NULL)
	{
		printf("Open key file fail\n");
		return NULL;
	}
	if ((pRsa = PEM_read_RSAPrivateKey(pPrikey, NULL, NULL, NULL)) == NULL)
	{
		printf("Read private key fail\n");
		return NULL;
	}
	nRsalen = RSA_size(pRsa);
	pDedata = (char*)malloc(nRsalen + 1);
	memset(pDedata, 0, nRsalen + 1);
	if (RSA_private_decrypt(nRsalen, (unsigned char*)str, (unsigned
		char*)pDedata, pRsa, RSA_PKCS1_PADDING) < 0)
	{
		printf("Decrypt private key fail\n");
		return NULL;
	}

	RSA_free(pRsa);
	fclose(pPrikey);
	return pDedata;
}

char* rc4_decrypt_file(char* file_data, int data_size,
	const char* rc4_dencrypt_key, int encrypt_chunk_size = 16)
{
	char* out_data_all = NULL;
	if ((out_data_all = (char*)malloc(data_size)) == NULL)
	{
		printf("no enough memory!\n");
		return 0;
	}
	memset(out_data_all, 0, data_size);

	char code[64] = { 0 };
	int codelen = sizeof(code);
	RC4_KEY rc4_key;
	RC4_set_key(&rc4_key, strlen(rc4_dencrypt_key), (unsigned char*)rc4_dencrypt_key);

	char* in_data = new char[encrypt_chunk_size + 1];
	char* out_data = new char[encrypt_chunk_size + 1];

	int i = 0;
	//循环解密
	while (i < data_size)
	{
		encrypt_chunk_size = (data_size - i) / 16 > 0 ? 16 : data_size % 16;
		memcpy(in_data, (file_data + i), encrypt_chunk_size);
		RC4(&rc4_key, encrypt_chunk_size, (unsigned char*)in_data, (unsigned char*)out_data);
		memcpy(out_data_all + i, out_data, encrypt_chunk_size);
		i += encrypt_chunk_size;
	};

	char* restore_file_data = NULL;
	if ((restore_file_data = (char*)malloc(data_size - 0x12)) == NULL)
	{
		printf("no enough memory!\n");
		return 0;
	}
	memset(restore_file_data, 0, data_size - 0x12);
	memcpy(restore_file_data, out_data_all + 0x9, data_size - 0x12);

	RELESE_ARRAY(in_data);
	RELESE_ARRAY(out_data);
	RELESE_ARRAY(out_data_all);
	return restore_file_data;
}

bool load_file(char* loadFileName)
{
	FILE* pFile;

	pFile = fopen(loadFileName, "rb");
	if (pFile == NULL)
	{
		printf("Open file fail\n");
		return false;
	}

	fseek(pFile, 0, SEEK_END);
	lSize = ftell(pFile);
	rewind(pFile);

	buffer = (char*)malloc(sizeof(char) * lSize);
	if (buffer == NULL)
	{
		printf("Malloc memory fail\n");
		return false;
	}

	result = fread(buffer, 1, lSize, pFile);
	if (result != lSize)
	{
		fputs("Reading error", stderr);
		printf("Load file to memory falil");
		return false;
	}
	return true;
}


char* get_rc4_key()
{
	char file_key[256] = { 0 };
	memcpy(file_key, (BYTE*)(buffer + 0xB), 0x100);
	return decrypt_cr4_key(file_key, OPENSSLKEY);
}

bool decrypt_file(char* loadFileName)
{
	char* rc4key = NULL;
	char* file_data = NULL;

	if (!load_file(loadFileName))
	{
		printf("Load file fail\n");
		return false;
	}
	rc4key = get_rc4_key();
	if ((file_data = (char*)malloc(lSize - 0x11F)) == NULL)
	{
		printf("Malloc memory fail\n");
		return -1;
	}
	memset(file_data, 0, lSize - 0x11F);
	memcpy(file_data, (BYTE*)(buffer + 0x116), lSize - 0x11F);

	//调用RC4解密数据块，返回解密数据
	file_data = rc4_decrypt_file(file_data, lSize - 0x11F, rc4key);


	//保存到文件
	FILE* p2file;
	char outFile[MAX_PATH];
	memset(outFile, 0, sizeof(outFile));
	memcpy(outFile, loadFileName, strlen(loadFileName));
	//截断后缀
	char* set = strrchr(outFile, (char)0x2E);
	*set = 0x00;

	p2file = fopen(outFile, "wb");
	int a = fwrite(file_data, lSize - 0x11F - 0x12, 1, p2file);
	fclose(p2file);
	printf("Decrypt file success\n");
	RELESE_ARRAY(file_data);
	return true;
}


int main(int argc, char* argv[]) 
{
	szFilepath = argv[2];
	decrypt_file(argv[1]);
	return 0;
}